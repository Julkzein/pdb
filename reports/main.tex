\documentclass[a4paper,12pt,onecolumn]{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage{lipsum} 
\usepackage{fullpage}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumerate}
\usepackage{color}
\usepackage{capt-of}
\usepackage{minted}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{bm}
\usepackage{csquotes}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{vmargin}
\setmarginsrb{2.5 cm}{1.5 cm}{2.5 cm}{2 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}
\usepackage{fancyhdr}

\usepackage[
backend=biber,
style=numeric,
sorting=ynt
]{biblatex}

\addbibresource{References.bib}

\pagestyle{fancy}
\usepackage{lastpage}
\fancyhf{}
\setlength\headheight{15pt}
\fancyhead[L]{\shorttitle}
\fancyhead[R]{CHILI}
\fancyfoot[R]{\thepage}%/\pageref{LastPage}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{A Web Platform for\\Orchestration Graph-Based \\ Lesson Planning}
\author{Jules Delforge}
\newcommand{\thesupervisor}{Pierre Dillenbourg}
\date{\today}
\newcommand{\shorttitle}{Orchestration Graph Platform}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother
\begin{document}
\begin{titlepage}
	\centering
\begin{figure}[!tbp]
  \centering
  \begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=0.6\textwidth]{EPFL.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=1.1\textwidth]{CHILI.png}
  \end{minipage}
\end{figure}
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
			\emph{Author: }\\
			\theauthor\\[2cm]	
            \emph{Professor and Supervisor:} \\
            Pierre Dillenbourg\\[2cm]
	{\large \thedate}\\[2 cm]
	\vfill
\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\medskip
\clearpage
\setcounter{page}{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgments}

I am grateful to Pierre Dillenbourg who presented the concept of Orchestration Graphs and the first ideas about how to build off of Samuel’s project. Then, he provided supervision
and insightful ideas throughout the semester

I acknowledge the use of CLAUDE (Anthropic) for planning and overview when I lacked the ability to see where the issue was coming from or when I wasn't sure how to proceed. 


\section{Introduction}

Educational lesson planning requires balancing multiple pedagogical constraints: learning objectives, time budgets, prerequisite knowledge, and organizational structures. This project builds a web-based application for designing lesson plans leveraging \emph{orchestration graphs}, a computational framework that models student understanding as a progression through a multi-dimensional state space \cite{Belisle2024}. The work modernizes Samuel Bélisle's Qt/QML desktop application by migrating to a full-stack web platform while preserving the core pedagogical algorithms.

This work builds directly upon the orchestration graph engine developed by Samuel Bélisle \cite{Belisle2024}, available at \url{https://github.com/Katokoda/OG_QML}. While the core pedagogical algorithms are mostly preserved, the contribution of this project lies in migrating the system to a web-based architecture and making targeted corrections to the recommendation logic. These changes aim to improve accessibility and algorithmic behavior without altering the conceptual foundations of orchestration graphs.

One may find the repo for this project here \url{https://github.com/Julkzein/pdb}


\section{Literature Review}

\subsection{Orchestration in Educational Technology}


Educational orchestration refers to coordinating learning activities, resources, and social configurations to achieve pedagogical goals \cite{Dillenbourg2011,Prieto2011}. Orchestration graphs represent lesson plans as state-space transitions, where activities move students from one knowledge state to another.

\subsection{Activity-Based Learning Models}

Activities are organized across three social planes: \textbf{Individual} (personalized learning), \textbf{Team} (collaborative peer learning), and \textbf{Class} (whole-class instruction). Each activity has prerequisite conditions, learning effects, and temporal constraints, enabling activity sequencing and optimization.

\subsection{Computational Approaches to Lesson Planning}

The orchestration graph approach uses a greedy gap-filling algorithm that prioritizes efficiency (learning progress per unit time). Unlike constraint satisfaction or genetic algorithms that search for global optima, the greedy method provides locally optimal choices, trading solution quality for computational efficiency and interactive responsiveness. This design supports real-time teacher interaction but does not address multi-objective optimization or student-specific adaptation.

\section{Material and Methods}

\subsection{System Architecture}

The application uses a client-server architecture where the React frontend communicates with a Flask backend through a REST API. This separation emerged as necessary after an early attempt to integrate Samuel's Qt code directly.

\subsubsection{Backend Architecture}

The backend is built in pure Python 3.8+ using Flask, deliberately avoiding any Qt dependencies from Samuel's original implementation. The main challenge was extracting the orchestration algorithms from their Qt signal/slot structure while preserving exact behavior. From there were created the \texttt{*\_pure.py} versions of each module that replaced Qt signals with simple Python return values. This took longer than anticipated because Samuel's code relied heavily on Qt's property binding system for state updates. I had to manually trace each signal connection to understand the update flow.

Initially, all endpoints of the Flask API were synchronous, which caused the frontend to freeze during expensive operations like auto-complete. Recommendation endpoints were refactored to use longer timeouts while keeping simple operations fast. This wasn't an optimal solution as a proper solution would use WebSockets for long operations—but it was pragmatic given time constraints.

\subsubsection{Frontend Architecture}

The frontend uses React 18 with TypeScript, primarily because TypeScript's type checking caught numerous bugs during development when translating between Samuel's Python data structures and JavaScript objects. Zustand was chosen for state management over Redux because the orchestration state is fundamentally a single object tree that maps well to Zustand's simple store model. React DnD handles drag-and-drop, though I initially tried react-beautiful-dnd before discovering that it couldn't handle the absolute positioning requirements of the timeline (activities must be positioned by time, not insertion order).

The most challenging architectural decision was handling state synchronization between frontend and backend. Every activity insertion triggers a backend recalculation of the entire orchestration graph (gap evaluation, state progression, constraint checking). I initially tried optimistic updates where the UI would update immediately and roll back on validation failure, but this caused flicker when activities were rejected. The current implementation blocks on backend responses, which feels slower but prevents confusing state inconsistencies. A better solution would compute preview states client-side before committing to the backend, but this would require duplicating Samuel's algorithms in TypeScript.

\subsubsection{Development Process and Architecture Decisions}

The initial development approach attempted to build a baseline web application with a simplified mock orchestration engine, planning to integrate Samuel's engine later. This seemed reasonable for rapid prototyping, but I quickly realized it wouldn't work: the mock engine lacked the nuanced state progression logic, gap evaluation, and efficiency calculations that make the system functional. More importantly, building the UI around a simplified model would require significant refactoring when integrating the real engine.

Pivoting to building directly around Samuel's engine required creating the clean separation between orchestration logic and web framework described above. The Flask API layer wraps these pure Python modules, translating between HTTP requests and method calls. This separation proved essential for testing and maintainability, but created tight coupling to Samuel's data structures and method signatures, limiting flexibility for future modifications.

\subsection{Our Model of a Lesson}

A lesson in the orchestration graph system is represented as a sequence of activities that take the class from an initial state to a target goal state. The model reduces the state of each student's understanding into two values: $p_{\text{depth}}$ (depth of understanding) and $p_{\text{fluency}}$ (fluency in achieving the task), both ranging from zero to one. Each activity has prerequisite conditions ($c_{\text{depth}}, c_{\text{fluency}}$) that must be satisfied and produces effects ($e_{\text{depth}}, e_{\text{fluency}}$) that modify the student state. Activities are positioned sequentially in time and assigned to one of three organizational planes: Individual, Team, or Class. The system enforces temporal constraints through a time budget, representing lesson time. See Samuel's report \cite{Belisle2024} for more details and explanation.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{Orchestration_Graph.png}
\caption{State-space visualization showing learning trajectory through fluency-depth space. Orange X: initial state, blue X: goal state.}
\label{fig:graph}
\end{figure}


\subsection{Core Algorithms}

The core orchestration algorithms are preserved from the original Qt/QML implementation \cite{Belisle2024}. The system evaluates learning gaps where the current state is insufficient to reach prerequisites or goals, and employs a greedy recommendation algorithm that selects activities maximizing learning progress per unit time. Some modifications were done on this algorithm. 

The primary modification was fixing the distance metric for gap evaluation. The original Euclidean distance $d(s_1, s_2) = \sqrt{\sum_{i}(s_{1,i} - s_{2,i})^2}$ scores activities poorly when current state exceeds their prerequisites, even though exceeding prerequisites is pedagogically acceptable. Above all, it stops some valuable activities to be considered. The fix uses forward-only distance $d_{\text{forward}}(s_1, s_2) = \sqrt{\sum_{i: s_{1,i} < s_{2,i}}(s_{1,i} - s_{2,i})^2}$, which only considers dimensions requiring progress.

This bug particularly affected scenarios with unbalanced skill profiles. Consider the lesson shown in Figure~\ref{fig:unbalanced_example}, where after two fluency focused activities, students have high fluency (0.7) but a low depth (0.22). Here, the engine would wrongly not propose activities needing low fluency as the student would be ``overqualified'' even if this was the optimal activity in terms of building depth. However, one may argue that if an ``overqualified'' student is exposed to an easier exercise, they might be less inclined to follow it which could justify the original distance metric even though it is less optimal. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.75\textwidth]{HighFluency_LowDepth.png}
    \caption{Example of unbalanced skill progression requiring depth-focused activities.}
    \label{fig:unbalanced_example}
\end{figure}

I also corrected a constraint validation bug in \texttt{okeyToTake()} that only checked the \texttt{noProgress} flag, allowing exhausted or over-budget activities. 


\subsection{User Interface Design}

The interface consists of a timeline with three lanes (Individual, Team, Class), an activity library panel with draggable cards, and a management toolbar. Activities are positioned by \texttt{startsAfter} time with drag-and-drop placement, hover information, gap indicators, and real-time validation. Matplotlib generates 2D state-space visualizations as static PNGs.


The application integrates DeepSeek AI to generate age-appropriate teaching resources including explanations, prompts, materials, and assessments. The implementation uses a two-tier prompt structure for enlarged context: a global system prompt defining the educational consultant role and output format, plus activity-specific prompts from the CSV library explaining the idea precisely by taking information from the activity object. DeepSeek was selected for cost-effectiveness. Only non-sensitive data is transmitted (activity descriptions, age group, subject) making the choice of LLM not so crucial. 

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{Orchestration_Timeline.png}
\caption{Orchestration timeline with activities across three organizational planes, showing real-time gap feedback and temporal positioning.}
\label{fig:timeline}
\end{figure}


\section{Results}

\subsection{User Interface Implementation}

The web application offers automated lesson generation or manual orchestration control. The timeline (Figure \ref{fig:timeline}) arranges activities in draggable activity cards across three organizational planes (Individual, Team, Class) with left-to-right time progression, displaying real-time gap metrics and goal achievement status. State-space visualization (Figure \ref{fig:graph}) plots learning trajectories in 2D fluency-depth space, with activity effects as rectangles and arrows showing state transitions between starting point (orange X) and goal (blue X).



LLM integration generates age-appropriate teaching materials including pedagogical suggestions, activity-specific examples, categorized resources (videos, worksheets, simulations), and teaching tips with concrete examples, URLs, and time management strategies.

\subsection{System Capabilities and Design Trade-offs}

The system supports flexible-duration activities with effects scaling through linear interpolation. The recommendation engine computes forward-only distance to prerequisites and goals, selecting activities maximizing $\eta = \Delta d / t$ (gap closure per minute). Auto-completion took 2-8 iterations for typical 60-minute lessons. The CSV-based activity library allows Excel editing but lacks validation, concurrent access, and versioning—acceptable for prototyping but requiring database migration for production.

\subsection{Performance Analysis}

Performance profiling on M2 Macbook Air (Python 3.11):

\begin{table}[htbp]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Operation} & \textbf{10 activities} & \textbf{50 activities} & \textbf{Complexity} \\
\midrule
Gap evaluation & 0.8ms & 3.2ms & $O(n)$ \\
Recommendation calc & 12ms & 58ms & $O(n \cdot m)$ \\
Graph visualization & 95ms & 210ms & $O(n)$ \\
Frontend re-render & 18ms & 22ms & $O(1)$ \\
\bottomrule
\end{tabular}
\caption{Backend performance metrics showing orchestration operations remain under 100ms for realistic library sizes.}
\end{table}

Critical bottleneck: LLM API calls (15-45s, dominated by network). Backend orchestration operations remain $<$100ms for realistic library sizes ($n<50$), making them imperceptible to users. The greedy algorithm's $O(n \cdot m)$ complexity means 100 activities would require $\sim$115ms per recommendation which is largely acceptable for interactive use.

\subsection{Architecture Benefits}

The web architecture enables browser-based access without installation and provides REST API extensibility for future integrations. However, deployment is more complex than the original single-executable Qt application, requiring separate backend and frontend hosting.

\section{Conclusion}

This project demonstrates that orchestration graph algorithms can be extracted from desktop frameworks and delivered through web browsers. The technical migration succeeded: the system functions equivalently to Samuel's Qt application, with the same recommendation logic and gap evaluation algorithms. The web platform requires no installation and runs on any device with a browser, which theoretically improves accessibility. However, I lack further tests with teachers to evaluate the limits of this application. 

\subsection{Key Contributions}

This project makes three concrete contributions beyond Samuel's original work:

\textbf{Web Platform Migration}: I successfully decoupled the orchestration algorithms from Qt dependencies, creating pure Python modules that can be reused in other projects. This required reverse-engineering Samuel's signal/slot architecture to understand state update flows, which was more difficult than anticipated because Qt's property binding system has implicit dependencies that are not visible in the code. The resulting Flask API provides 15 endpoints covering all orchestration operations, enabling future integration with learning management systems or mobile applications.

\textbf{Distance Metric Correction}: The forward-only distance function fixes a subtle but impactful bug in the original recommendation algorithm. This represents an edge case that can block an otherwise optimal activity. While this is a small algorithmic change, it's interesting to see how the engine evaluates learning gaps when students have unbalanced skill profiles.

\textbf{LLM-Enhanced Teacher Materials}: The DeepSeek integration generates contextualized teaching resources automatically. However, I must acknowledge this feature's limitations as the prompts for the resource generations were not further studied or engineered.  This remains a proof-of-concept rather than a production-ready feature.

\subsection{Limitations and Reflections}

The greedy recommendation algorithm can make locally optimal choices that prevent reaching the goal. Auto-complete occasionally fails even when valid solutions exist, Samuel's thesis proposes backtracking, which I did not implement. Increasing to higher dimensions to better represent learning may need complications of the engine. The Flask API exposes internal data structures directly, creating tight coupling between frontend and backend, a better approach could use explicit API schemas like Pydantic or OpenAPI to provide a stable contract.

\subsection{Real-World Testing and Impact}

I tested the system during several workshops I gave and made two friends test it for workshops they were giving. The auto-generated full orchestration graphs were not personalised enough but both appreciated manually creating their orchestration graphs, one even adding an activity. LLM-generated examples received mixed feedback: the exercises given were not the best (although treated subjects were complex) but the examples were pertinent and the sources provided of great use. Maybe refining the prompts would be a good domain to explore. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\printbibliography
\end{document}
